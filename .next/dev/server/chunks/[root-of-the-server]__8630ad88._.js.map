{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/lib/data/mockData.ts"],"sourcesContent":["import { Farm, BurningRecord, InsurancePayment } from '@/lib/types/farm';\n\n// Mock farm data\nexport const MOCK_FARMS: Farm[] = [\n  {\n    id: 'farm1',\n    name: 'Green Valley Farm',\n    owner: 'สมชาย ใจดี',\n    walletAddress: '0x1234567890123456789012345678901234567890',\n    location: { lat: 13.7563, lng: 100.5018 },\n    area: 25.5,\n    registrationDate: '2024-01-15',\n    lastCheckDate: '2026-01-28',\n    hasBurning: false,\n    burningIncidents: 0,\n    insuranceStatus: 'active',\n    rewardAmount: 500,\n  },\n  {\n    id: 'farm2',\n    name: 'Sunrise Orchards',\n    owner: 'นิรันดร์ สุขสวัสดิ์',\n    walletAddress: '0x2345678901234567890123456789012345678901',\n    location: { lat: 14.3532, lng: 100.5698 },\n    area: 18.2,\n    registrationDate: '2024-02-20',\n    lastCheckDate: '2026-01-28',\n    hasBurning: true,\n    burningIncidents: 2,\n    insuranceStatus: 'ineligible',\n    rewardAmount: 0,\n  },\n  {\n    id: 'farm3',\n    name: 'Golden Harvest Fields',\n    owner: 'อภิญญา วงศ์สกุล',\n    walletAddress: '0x3456789012345678901234567890123456789012',\n    location: { lat: 15.8700, lng: 100.9925 },\n    area: 42.0,\n    registrationDate: '2024-03-10',\n    lastCheckDate: '2026-01-28',\n    hasBurning: false,\n    burningIncidents: 0,\n    insuranceStatus: 'paid',\n    rewardAmount: 800,\n  },\n  {\n    id: 'farm4',\n    name: 'River Bend Agriculture',\n    owner: 'กิตติศักดิ์ เจริญผล',\n    walletAddress: '0x4567890123456789012345678901234567890123',\n    location: { lat: 16.4419, lng: 102.8359 },\n    area: 33.7,\n    registrationDate: '2024-04-05',\n    lastCheckDate: '2026-01-28',\n    hasBurning: false,\n    burningIncidents: 0,\n    insuranceStatus: 'pending',\n    rewardAmount: 650,\n  },\n  {\n    id: 'farm5',\n    name: 'Mountain View Plantation',\n    owner: 'ปราณี ศรีสุข',\n    walletAddress: '0x5678901234567890123456789012345678901234',\n    location: { lat: 18.7883, lng: 98.9853 },\n    area: 51.3,\n    registrationDate: '2024-05-12',\n    lastCheckDate: '2026-01-28',\n    hasBurning: true,\n    burningIncidents: 1,\n    insuranceStatus: 'ineligible',\n    rewardAmount: 0,\n  },\n];\n\n// Mock burning records\nexport const MOCK_BURNING_RECORDS: BurningRecord[] = [\n  {\n    farmId: 'farm2',\n    date: '2026-01-10',\n    severity: 'medium',\n    verified: true,\n  },\n  {\n    farmId: 'farm2',\n    date: '2026-01-22',\n    severity: 'low',\n    verified: true,\n  },\n  {\n    farmId: 'farm5',\n    date: '2026-01-18',\n    severity: 'high',\n    verified: true,\n  },\n];\n\n// Mock insurance payments\nexport const MOCK_PAYMENTS: InsurancePayment[] = [\n  {\n    farmId: 'farm1',\n    amount: 500,\n    timestamp: '2026-01-28T10:00:00Z',\n    status: 'pending',\n  },\n  {\n    farmId: 'farm3',\n    amount: 800,\n    timestamp: '2026-01-27T15:30:00Z',\n    txHash: '0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890',\n    status: 'completed',\n  },\n  {\n    farmId: 'farm4',\n    amount: 650,\n    timestamp: '2026-01-28T09:15:00Z',\n    status: 'pending',\n  },\n];\n"],"names":[],"mappings":";;;;;;;;AAGO,MAAM,aAAqB;IAChC;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAQ;QACvC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;CACD;AAGM,MAAM,uBAAwC;IACnD;QACE,QAAQ;QACR,MAAM;QACN,UAAU;QACV,UAAU;IACZ;IACA;QACE,QAAQ;QACR,MAAM;QACN,UAAU;QACV,UAAU;IACZ;IACA;QACE,QAAQ;QACR,MAAM;QACN,UAAU;QACV,UAAU;IACZ;CACD;AAGM,MAAM,gBAAoC;IAC/C;QACE,QAAQ;QACR,QAAQ;QACR,WAAW;QACX,QAAQ;IACV;IACA;QACE,QAAQ;QACR,QAAQ;QACR,WAAW;QACX,QAAQ;QACR,QAAQ;IACV;IACA;QACE,QAAQ;QACR,QAAQ;QACR,WAAW;QACX,QAAQ;IACV;CACD"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/lib/zktls/types.ts"],"sourcesContent":["// Primus zkTLS Types for GISTDA Integration\n\nexport interface ZkTLSConfig {\n  appId: string;\n  appSecret: string;\n  templateId: string;\n  mode: 'proxytls' | 'mpctls';\n}\n\nexport interface AttestationRequest {\n  templateId: string;\n  userAddress: string;\n  mode: 'proxytls' | 'mpctls';\n  conditions?: AttestationCondition[][];\n}\n\nexport interface AttestationCondition {\n  field: string;\n  op: 'SHA256' | '>' | '<' | '=' | '!=' | '>=' | '<=';\n  value?: string;\n}\n\nexport interface AttestationResult {\n  success: boolean;\n  attestationId: string;\n  timestamp: number;\n  data: {\n    farmId: string;\n    gistdaId: string;\n    noBurningDetected: boolean;\n    hotspotsCount: number;\n    checkDate: string;\n    location: {\n      lat: number;\n      lng: number;\n    };\n  };\n  proof: {\n    hash: string;\n    signature: string;\n    attestorPublicKey: string;\n  };\n  rawResponse?: unknown;\n}\n\nexport interface VerificationResult {\n  verified: boolean;\n  attestation: AttestationResult | null;\n  error?: string;\n}\n\nexport interface GISTDAHotspotData {\n  totalHotspots: number;\n  hotspots: Array<{\n    latitude: number;\n    longitude: number;\n    acquisitionDate: string;\n    confidence: string;\n    brightness: number;\n    landUse: string;\n  }>;\n  queryArea: {\n    minLat: number;\n    maxLat: number;\n    minLng: number;\n    maxLng: number;\n  };\n  status: 'NO_BURNING' | 'BURNING_DETECTED' | 'ERROR';\n}\n\n// GISTDA API Response structure\nexport interface GISTDAApiResponse {\n  features?: Array<{\n    attributes: {\n      OBJECTID: number;\n      latitude: number;\n      longitude: number;\n      acq_date: string;\n      confidence: string;\n      brightness: number;\n      lu_name: string;\n    };\n    geometry?: {\n      x: number;\n      y: number;\n    };\n  }>;\n  error?: {\n    code: number;\n    message: string;\n  };\n}\n\n// Primus SDK Response Types (based on official SDK)\nexport interface PrimusAttestationResponse {\n  attestation: {\n    id: string;\n    timestamp: string;\n    data: Record<string, unknown>;\n    signature: string;\n    publicKey: string;\n  };\n  verified: boolean;\n}\n"],"names":[],"mappings":"AAAA,4CAA4C"}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/lib/zktls/primusClient.ts"],"sourcesContent":["/**\n * Primus zkTLS Client for GISTDA Verification\n * \n * This module provides zkTLS integration with Thailand's GISTDA portal\n * for verifying farm burning status using cryptographic proofs.\n * \n * @see https://docs.primuslabs.xyz/enterprise/zk-tls-sdk/overview\n */\n\nimport {\n  ZkTLSConfig,\n  AttestationResult,\n  VerificationResult,\n  GISTDAHotspotData,\n  GISTDAApiResponse,\n} from './types';\n\n// Environment configuration\nconst PRIMUS_CONFIG: ZkTLSConfig = {\n  appId: process.env.NEXT_PUBLIC_PRIMUS_APP_ID || 'demo_app_id',\n  appSecret: process.env.PRIMUS_APP_SECRET || 'demo_app_secret',\n  templateId: process.env.NEXT_PUBLIC_PRIMUS_TEMPLATE_ID || 'gistda_hotspot_template',\n  mode: 'proxytls', // Default to proxy mode for better performance\n};\n\n// GISTDA API Configuration\nconst GISTDA_CONFIG = {\n  baseUrl: 'https://gistdaportal.gistda.or.th/data/rest/services/FR_Fire/hotspot_npp_daily/MapServer/0/query',\n  agriculturalLandFilter: \"lu_name='พื้นที่เกษตร'\", // Filter for agricultural land\n  defaultBufferKm: 1, // 1km buffer around farm location\n};\n\n/**\n * Query GISTDA API for hotspots at a specific location\n */\nexport async function queryGISTDAHotspots(\n  lat: number,\n  lng: number,\n  bufferKm: number = GISTDA_CONFIG.defaultBufferKm\n): Promise<GISTDAHotspotData> {\n  // Convert km to approximate degrees (1 degree ≈ 111km at equator)\n  const buffer = bufferKm / 111;\n\n  const params = new URLSearchParams({\n    where: GISTDA_CONFIG.agriculturalLandFilter,\n    geometry: `${lng - buffer},${lat - buffer},${lng + buffer},${lat + buffer}`,\n    geometryType: 'esriGeometryEnvelope',\n    spatialRel: 'esriSpatialRelIntersects',\n    outFields: '*',\n    f: 'json',\n  });\n\n  const url = `${GISTDA_CONFIG.baseUrl}?${params.toString()}`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: { 'Accept': 'application/json' },\n      signal: AbortSignal.timeout(30000),\n    });\n\n    if (!response.ok) {\n      throw new Error(`GISTDA API error: ${response.status}`);\n    }\n\n    const data: GISTDAApiResponse = await response.json();\n\n    if (data.error) {\n      throw new Error(`GISTDA API error: ${data.error.message}`);\n    }\n\n    const hotspots = (data.features || []).map(f => ({\n      latitude: f.attributes.latitude || f.geometry?.y || 0,\n      longitude: f.attributes.longitude || f.geometry?.x || 0,\n      acquisitionDate: f.attributes.acq_date,\n      confidence: f.attributes.confidence,\n      brightness: f.attributes.brightness,\n      landUse: f.attributes.lu_name,\n    }));\n\n    return {\n      totalHotspots: hotspots.length,\n      hotspots,\n      queryArea: {\n        minLat: lat - buffer,\n        maxLat: lat + buffer,\n        minLng: lng - buffer,\n        maxLng: lng + buffer,\n      },\n      status: hotspots.length === 0 ? 'NO_BURNING' : 'BURNING_DETECTED',\n    };\n  } catch (error) {\n    console.error('GISTDA API query failed:', error);\n    return {\n      totalHotspots: -1,\n      hotspots: [],\n      queryArea: {\n        minLat: lat - buffer,\n        maxLat: lat + buffer,\n        minLng: lng - buffer,\n        maxLng: lng + buffer,\n      },\n      status: 'ERROR',\n    };\n  }\n}\n\n/**\n * Generate a cryptographic proof hash for the attestation\n * In production, this would be generated by the Primus zkTLS SDK\n */\nfunction generateProofHash(data: Record<string, unknown>): string {\n  const jsonStr = JSON.stringify(data);\n  let hash = 0;\n  for (let i = 0; i < jsonStr.length; i++) {\n    const char = jsonStr.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return '0x' + Math.abs(hash).toString(16).padStart(64, '0');\n}\n\n/**\n * Generate zkTLS attestation signature (simulated)\n * In production, this would be signed by Primus attestors\n */\nfunction generateAttestationSignature(proofHash: string, timestamp: number): string {\n  const data = `${proofHash}:${timestamp}:${PRIMUS_CONFIG.appId}`;\n  let sig = 0;\n  for (let i = 0; i < data.length; i++) {\n    sig = ((sig << 7) - sig) + data.charCodeAt(i);\n    sig = sig & sig;\n  }\n  return '0x' + Math.abs(sig).toString(16).padStart(128, '0');\n}\n\n/**\n * Create zkTLS attestation for GISTDA hotspot verification\n * \n * This function:\n * 1. Queries GISTDA API for hotspots at farm location\n * 2. Creates a cryptographic attestation of the result\n * 3. Returns proof that can be submitted on-chain\n * \n * @param farmId - Unique farm identifier\n * @param gistdaId - GISTDA portal farm ID\n * @param lat - Farm latitude\n * @param lng - Farm longitude\n * @param userAddress - User's wallet address\n */\nexport async function createGISTDAAttestation(\n  farmId: string,\n  gistdaId: string,\n  lat: number,\n  lng: number,\n  userAddress: string\n): Promise<AttestationResult> {\n  const timestamp = Date.now();\n  const checkDate = new Date(timestamp).toISOString();\n\n  // Step 1: Query GISTDA API for hotspot data\n  const gistdaData = await queryGISTDAHotspots(lat, lng);\n\n  // Step 2: Prepare attestation data\n  const attestationData = {\n    farmId,\n    gistdaId,\n    noBurningDetected: gistdaData.status === 'NO_BURNING',\n    hotspotsCount: gistdaData.totalHotspots,\n    checkDate,\n    location: { lat, lng },\n    queryArea: gistdaData.queryArea,\n    userAddress,\n    appId: PRIMUS_CONFIG.appId,\n    templateId: PRIMUS_CONFIG.templateId,\n    mode: PRIMUS_CONFIG.mode,\n  };\n\n  // Step 3: Generate cryptographic proof\n  const proofHash = generateProofHash(attestationData);\n  const signature = generateAttestationSignature(proofHash, timestamp);\n\n  // Step 4: Create attestation result\n  const attestation: AttestationResult = {\n    success: gistdaData.status !== 'ERROR',\n    attestationId: `att_${farmId}_${timestamp}`,\n    timestamp,\n    data: {\n      farmId,\n      gistdaId,\n      noBurningDetected: gistdaData.status === 'NO_BURNING',\n      hotspotsCount: gistdaData.totalHotspots,\n      checkDate,\n      location: { lat, lng },\n    },\n    proof: {\n      hash: proofHash,\n      signature,\n      attestorPublicKey: 'primus_attestor_pubkey_demo',\n    },\n    rawResponse: gistdaData,\n  };\n\n  return attestation;\n}\n\n/**\n * Verify a zkTLS attestation\n * \n * In production, this would verify:\n * 1. The signature is valid from a trusted Primus attestor\n * 2. The proof hash matches the attestation data\n * 3. The attestation is not expired\n */\nexport async function verifyAttestation(\n  attestation: AttestationResult\n): Promise<VerificationResult> {\n  try {\n    // Verify attestation is not too old (24 hours max)\n    const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n    const age = Date.now() - attestation.timestamp;\n    \n    if (age > maxAge) {\n      return {\n        verified: false,\n        attestation: null,\n        error: 'Attestation has expired (older than 24 hours)',\n      };\n    }\n\n    // Verify proof hash matches data\n    const expectedHash = generateProofHash({\n      farmId: attestation.data.farmId,\n      gistdaId: attestation.data.gistdaId,\n      noBurningDetected: attestation.data.noBurningDetected,\n      hotspotsCount: attestation.data.hotspotsCount,\n      checkDate: attestation.data.checkDate,\n      location: attestation.data.location,\n      queryArea: (attestation.rawResponse as GISTDAHotspotData)?.queryArea,\n      userAddress: '', // Not included in verification\n      appId: PRIMUS_CONFIG.appId,\n      templateId: PRIMUS_CONFIG.templateId,\n      mode: PRIMUS_CONFIG.mode,\n    });\n\n    // In production, verify signature with Primus attestor public key\n    // For demo, we just check the attestation was successful\n    if (!attestation.success) {\n      return {\n        verified: false,\n        attestation,\n        error: 'Attestation was not successful',\n      };\n    }\n\n    return {\n      verified: true,\n      attestation,\n    };\n  } catch (error) {\n    return {\n      verified: false,\n      attestation: null,\n      error: error instanceof Error ? error.message : 'Verification failed',\n    };\n  }\n}\n\n/**\n * Format attestation for on-chain submission\n * Returns data structured for smart contract interaction\n */\nexport function formatForOnChain(attestation: AttestationResult): {\n  farmId: string;\n  proofHash: string;\n  noBurningDetected: boolean;\n  timestamp: number;\n} {\n  return {\n    farmId: attestation.data.farmId,\n    proofHash: attestation.proof.hash,\n    noBurningDetected: attestation.data.noBurningDetected,\n    timestamp: attestation.timestamp,\n  };\n}\n\n/**\n * Get Primus configuration (without secrets)\n */\nexport function getPublicConfig(): Omit<ZkTLSConfig, 'appSecret'> {\n  return {\n    appId: PRIMUS_CONFIG.appId,\n    templateId: PRIMUS_CONFIG.templateId,\n    mode: PRIMUS_CONFIG.mode,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 427, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/lib/zktls/index.ts"],"sourcesContent":["/**\n * Primus zkTLS Integration for VeriFarm\n * \n * This module provides zkTLS-based verification of GISTDA hotspot data\n * for the Smog-Free Farmer Oracle project.\n * \n * @module zktls\n */\n\nexport * from './types';\nexport * from './primusClient';\n\n// Re-export main functions for convenience\nexport {\n  createGISTDAAttestation,\n  verifyAttestation,\n  queryGISTDAHotspots,\n  formatForOnChain,\n  getPublicConfig,\n} from './primusClient';\n"],"names":[],"mappings":";AAAA;;;;;;;CAOC,GAED;AACA"}},
    {"offset": {"line": 444, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/app/api/zktls/batch-attest/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { MOCK_FARMS } from '@/lib/data/mockData';\nimport {\n  createGISTDAAttestation,\n  verifyAttestation,\n  formatForOnChain,\n  getPublicConfig,\n} from '@/lib/zktls';\n\n/**\n * POST /api/zktls/batch-attest\n * \n * Create zkTLS attestations for all farms\n * \n * Request body (optional):\n * - farmIds: string[] - Specific farm IDs to attest (defaults to all)\n * - userAddress: string - User's wallet address\n * \n * Response:\n * - summary: Batch attestation summary\n * - attestations: Array of attestation results\n */\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json().catch(() => ({}));\n    const { \n      farmIds = MOCK_FARMS.map(f => f.id),\n      userAddress = '0x0000000000000000000000000000000000000000'\n    } = body;\n\n    // Filter farms\n    const farmsToAttest = MOCK_FARMS.filter(f => farmIds.includes(f.id));\n\n    if (farmsToAttest.length === 0) {\n      return NextResponse.json(\n        { success: false, error: 'No valid farms found' },\n        { status: 404 }\n      );\n    }\n\n    // Create attestations in parallel\n    const attestationPromises = farmsToAttest.map(async (farm) => {\n      try {\n        // Check if farm has burning detected (ineligible for zkTLS proof)\n        if (farm.hasBurning) {\n          return {\n            farmId: farm.id,\n            farmName: farm.name,\n            owner: farm.owner,\n            location: farm.location,\n            attestation: null,\n            verification: { \n              verified: false, \n              error: 'Farm has burning incidents detected - ineligible for clean air proof' \n            },\n            onChainData: null,\n            success: false,\n            reason: 'BURNING_DETECTED',\n            burningIncidents: farm.burningIncidents,\n          };\n        }\n\n        const attestation = await createGISTDAAttestation(\n          farm.id,\n          `GISTDA_${farm.id}`,\n          farm.location.lat,\n          farm.location.lng,\n          userAddress\n        );\n\n        const verification = await verifyAttestation(attestation);\n        const onChainData = formatForOnChain(attestation);\n\n        return {\n          farmId: farm.id,\n          farmName: farm.name,\n          owner: farm.owner,\n          location: farm.location,\n          attestation: {\n            id: attestation.attestationId,\n            timestamp: attestation.timestamp,\n            noBurningDetected: attestation.data.noBurningDetected,\n            hotspotsCount: attestation.data.hotspotsCount,\n            proofHash: attestation.proof.hash,\n          },\n          verification: {\n            verified: verification.verified,\n            error: verification.error,\n          },\n          onChainData,\n          success: attestation.success && verification.verified,\n        };\n      } catch (error) {\n        return {\n          farmId: farm.id,\n          farmName: farm.name,\n          owner: farm.owner,\n          location: farm.location,\n          attestation: null,\n          verification: { verified: false, error: error instanceof Error ? error.message : 'Failed' },\n          onChainData: null,\n          success: false,\n        };\n      }\n    });\n\n    const results = await Promise.all(attestationPromises);\n\n    // Calculate summary\n    const summary = {\n      totalFarms: results.length,\n      successfulAttestations: results.filter(r => r.success).length,\n      cleanFarms: results.filter(r => r.attestation?.noBurningDetected).length,\n      burningDetected: results.filter(r => r.attestation && !r.attestation.noBurningDetected).length,\n      failed: results.filter(r => !r.success).length,\n      attestedAt: new Date().toISOString(),\n    };\n\n    return NextResponse.json({\n      success: true,\n      summary,\n      attestations: results,\n      config: getPublicConfig(),\n    });\n  } catch (error) {\n    console.error('Batch zkTLS attestation error:', error);\n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : 'Batch attestation failed',\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}}]
}