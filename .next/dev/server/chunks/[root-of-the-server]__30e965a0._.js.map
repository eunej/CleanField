{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/lib/data/mockData.ts"],"sourcesContent":["import { Farm, BurningRecord, InsurancePayment } from '@/lib/types/farm';\n\n// Mock farm data\nexport const MOCK_FARMS: Farm[] = [\n  {\n    id: 'farm1',\n    name: 'Green Valley Farm',\n    owner: 'สมชาย ใจดี',\n    walletAddress: '0x1234567890123456789012345678901234567890',\n    location: { lat: 13.7563, lng: 100.5018 },\n    area: 25.5,\n    registrationDate: '2024-01-15',\n    lastCheckDate: '2026-01-28',\n    hasBurning: false,\n    burningIncidents: 0,\n    insuranceStatus: 'active',\n    rewardAmount: 500,\n  },\n  {\n    id: 'farm2',\n    name: 'Sunrise Orchards',\n    owner: 'นิรันดร์ สุขสวัสดิ์',\n    walletAddress: '0x2345678901234567890123456789012345678901',\n    location: { lat: 14.3532, lng: 100.5698 },\n    area: 18.2,\n    registrationDate: '2024-02-20',\n    lastCheckDate: '2026-01-28',\n    hasBurning: true,\n    burningIncidents: 2,\n    insuranceStatus: 'ineligible',\n    rewardAmount: 0,\n  },\n  {\n    id: 'farm3',\n    name: 'Golden Harvest Fields',\n    owner: 'อภิญญา วงศ์สกุล',\n    walletAddress: '0x3456789012345678901234567890123456789012',\n    location: { lat: 15.8700, lng: 100.9925 },\n    area: 42.0,\n    registrationDate: '2024-03-10',\n    lastCheckDate: '2026-01-28',\n    hasBurning: false,\n    burningIncidents: 0,\n    insuranceStatus: 'paid',\n    rewardAmount: 800,\n  },\n  {\n    id: 'farm4',\n    name: 'River Bend Agriculture',\n    owner: 'กิตติศักดิ์ เจริญผล',\n    walletAddress: '0x4567890123456789012345678901234567890123',\n    location: { lat: 16.4419, lng: 102.8359 },\n    area: 33.7,\n    registrationDate: '2024-04-05',\n    lastCheckDate: '2026-01-28',\n    hasBurning: false,\n    burningIncidents: 0,\n    insuranceStatus: 'pending',\n    rewardAmount: 650,\n  },\n  {\n    id: 'farm5',\n    name: 'Mountain View Plantation',\n    owner: 'ปราณี ศรีสุข',\n    walletAddress: '0x5678901234567890123456789012345678901234',\n    location: { lat: 18.7883, lng: 98.9853 },\n    area: 51.3,\n    registrationDate: '2024-05-12',\n    lastCheckDate: '2026-01-28',\n    hasBurning: true,\n    burningIncidents: 1,\n    insuranceStatus: 'ineligible',\n    rewardAmount: 0,\n  },\n];\n\n// Mock burning records\nexport const MOCK_BURNING_RECORDS: BurningRecord[] = [\n  {\n    farmId: 'farm2',\n    date: '2026-01-10',\n    severity: 'medium',\n    verified: true,\n  },\n  {\n    farmId: 'farm2',\n    date: '2026-01-22',\n    severity: 'low',\n    verified: true,\n  },\n  {\n    farmId: 'farm5',\n    date: '2026-01-18',\n    severity: 'high',\n    verified: true,\n  },\n];\n\n// Mock insurance payments\nexport const MOCK_PAYMENTS: InsurancePayment[] = [\n  {\n    farmId: 'farm1',\n    amount: 500,\n    timestamp: '2026-01-28T10:00:00Z',\n    status: 'pending',\n  },\n  {\n    farmId: 'farm3',\n    amount: 800,\n    timestamp: '2026-01-27T15:30:00Z',\n    txHash: '0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890',\n    status: 'completed',\n  },\n  {\n    farmId: 'farm4',\n    amount: 650,\n    timestamp: '2026-01-28T09:15:00Z',\n    status: 'pending',\n  },\n];\n"],"names":[],"mappings":";;;;;;;;AAGO,MAAM,aAAqB;IAChC;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAQ;QACvC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;CACD;AAGM,MAAM,uBAAwC;IACnD;QACE,QAAQ;QACR,MAAM;QACN,UAAU;QACV,UAAU;IACZ;IACA;QACE,QAAQ;QACR,MAAM;QACN,UAAU;QACV,UAAU;IACZ;IACA;QACE,QAAQ;QACR,MAAM;QACN,UAAU;QACV,UAAU;IACZ;CACD;AAGM,MAAM,gBAAoC;IAC/C;QACE,QAAQ;QACR,QAAQ;QACR,WAAW;QACX,QAAQ;IACV;IACA;QACE,QAAQ;QACR,QAAQ;QACR,WAAW;QACX,QAAQ;QACR,QAAQ;IACV;IACA;QACE,QAAQ;QACR,QAAQ;QACR,WAAW;QACX,QAAQ;IACV;CACD"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/lib/gistda/hotspotChecker.ts"],"sourcesContent":["// GISTDA Hotspot Detection Service\n// Checks for fire/burning hotspots at farm locations using GISTDA's API\n\nexport interface HotspotResult {\n  farmId: string;\n  farmLat: number;\n  farmLng: number;\n  hotspotsDetected: number;\n  noBurningDetected: boolean;\n  eligible: boolean;\n  checkDate: string;\n  hotspots: HotspotFeature[];\n  error?: string;\n}\n\nexport interface HotspotFeature {\n  objectId: number;\n  latitude: number;\n  longitude: number;\n  acqDate: string;\n  confidence: string;\n  brightness: number;\n  luName: string;\n}\n\nexport interface GISTDAResponse {\n  features?: Array<{\n    attributes: {\n      OBJECTID: number;\n      latitude: number;\n      longitude: number;\n      acq_date: string;\n      confidence: string;\n      brightness: number;\n      lu_name: string;\n      [key: string]: unknown;\n    };\n    geometry?: {\n      x: number;\n      y: number;\n    };\n  }>;\n  error?: {\n    code: number;\n    message: string;\n  };\n}\n\n/**\n * Check for hotspots at a farm location using GISTDA API\n * @param farmId - Farm identifier\n * @param farmLat - Farm latitude\n * @param farmLng - Farm longitude\n * @param bufferKm - Buffer radius in kilometers (default 1km = 0.01 degrees approx)\n * @returns HotspotResult with detection status\n */\nexport async function checkFarmHotspots(\n  farmId: string,\n  farmLat: number,\n  farmLng: number,\n  bufferKm: number = 1\n): Promise<HotspotResult> {\n  // Convert km to approximate degrees (1 degree ≈ 111km at equator)\n  const buffer = bufferKm / 111;\n  \n  // Build GISTDA API URL\n  // Query for agricultural land ('พื้นที่เกษตร') hotspots within bounding box\n  const baseUrl = 'https://gistdaportal.gistda.or.th/data/rest/services/FR_Fire/hotspot_npp_daily/MapServer/0/query';\n  \n  const params = new URLSearchParams({\n    where: \"lu_name='พื้นที่เกษตร'\", // Agricultural land only\n    geometry: `${farmLng - buffer},${farmLat - buffer},${farmLng + buffer},${farmLat + buffer}`,\n    geometryType: 'esriGeometryEnvelope',\n    spatialRel: 'esriSpatialRelIntersects',\n    outFields: '*',\n    f: 'json'\n  });\n\n  const url = `${baseUrl}?${params.toString()}`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n      },\n      // Add timeout\n      signal: AbortSignal.timeout(30000), // 30 second timeout\n    });\n\n    if (!response.ok) {\n      throw new Error(`GISTDA API error: ${response.status} ${response.statusText}`);\n    }\n\n    const data: GISTDAResponse = await response.json();\n\n    // Check for API error response\n    if (data.error) {\n      throw new Error(`GISTDA API error: ${data.error.message}`);\n    }\n\n    // Parse hotspot features\n    const hotspots: HotspotFeature[] = (data.features || []).map(feature => ({\n      objectId: feature.attributes.OBJECTID,\n      latitude: feature.attributes.latitude || feature.geometry?.y || 0,\n      longitude: feature.attributes.longitude || feature.geometry?.x || 0,\n      acqDate: feature.attributes.acq_date,\n      confidence: feature.attributes.confidence,\n      brightness: feature.attributes.brightness,\n      luName: feature.attributes.lu_name,\n    }));\n\n    const hotspotsDetected = hotspots.length;\n    const noBurningDetected = hotspotsDetected === 0;\n\n    return {\n      farmId,\n      farmLat,\n      farmLng,\n      hotspotsDetected,\n      noBurningDetected,\n      eligible: noBurningDetected, // Eligible for reward if no burning detected\n      checkDate: new Date().toISOString(),\n      hotspots,\n    };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    \n    return {\n      farmId,\n      farmLat,\n      farmLng,\n      hotspotsDetected: -1,\n      noBurningDetected: false,\n      eligible: false,\n      checkDate: new Date().toISOString(),\n      hotspots: [],\n      error: errorMessage,\n    };\n  }\n}\n\n/**\n * Generate a proof hash from hotspot check result\n * This would be replaced with actual zkTLS proof generation\n */\nexport function generateProofHash(result: HotspotResult): string {\n  const data = JSON.stringify({\n    farmId: result.farmId,\n    lat: result.farmLat,\n    lng: result.farmLng,\n    noBurning: result.noBurningDetected,\n    checkDate: result.checkDate,\n    hotspotsCount: result.hotspotsDetected,\n  });\n  \n  // Simple hash for demo - in production, this would be zkTLS proof\n  let hash = 0;\n  for (let i = 0; i < data.length; i++) {\n    const char = data.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  \n  return '0x' + Math.abs(hash).toString(16).padStart(64, '0');\n}\n"],"names":[],"mappings":"AAAA,mCAAmC;AACnC,wEAAwE;;;;;;;AAuDjE,eAAe,kBACpB,MAAc,EACd,OAAe,EACf,OAAe,EACf,WAAmB,CAAC;IAEpB,kEAAkE;IAClE,MAAM,SAAS,WAAW;IAE1B,uBAAuB;IACvB,4EAA4E;IAC5E,MAAM,UAAU;IAEhB,MAAM,SAAS,IAAI,gBAAgB;QACjC,OAAO;QACP,UAAU,GAAG,UAAU,OAAO,CAAC,EAAE,UAAU,OAAO,CAAC,EAAE,UAAU,OAAO,CAAC,EAAE,UAAU,QAAQ;QAC3F,cAAc;QACd,YAAY;QACZ,WAAW;QACX,GAAG;IACL;IAEA,MAAM,MAAM,GAAG,QAAQ,CAAC,EAAE,OAAO,QAAQ,IAAI;IAE7C,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,KAAK;YAChC,QAAQ;YACR,SAAS;gBACP,UAAU;YACZ;YACA,cAAc;YACd,QAAQ,YAAY,OAAO,CAAC;QAC9B;QAEA,IAAI,CAAC,SAAS,EAAE,EAAE;YAChB,MAAM,IAAI,MAAM,CAAC,kBAAkB,EAAE,SAAS,MAAM,CAAC,CAAC,EAAE,SAAS,UAAU,EAAE;QAC/E;QAEA,MAAM,OAAuB,MAAM,SAAS,IAAI;QAEhD,+BAA+B;QAC/B,IAAI,KAAK,KAAK,EAAE;YACd,MAAM,IAAI,MAAM,CAAC,kBAAkB,EAAE,KAAK,KAAK,CAAC,OAAO,EAAE;QAC3D;QAEA,yBAAyB;QACzB,MAAM,WAA6B,CAAC,KAAK,QAAQ,IAAI,EAAE,EAAE,GAAG,CAAC,CAAA,UAAW,CAAC;gBACvE,UAAU,QAAQ,UAAU,CAAC,QAAQ;gBACrC,UAAU,QAAQ,UAAU,CAAC,QAAQ,IAAI,QAAQ,QAAQ,EAAE,KAAK;gBAChE,WAAW,QAAQ,UAAU,CAAC,SAAS,IAAI,QAAQ,QAAQ,EAAE,KAAK;gBAClE,SAAS,QAAQ,UAAU,CAAC,QAAQ;gBACpC,YAAY,QAAQ,UAAU,CAAC,UAAU;gBACzC,YAAY,QAAQ,UAAU,CAAC,UAAU;gBACzC,QAAQ,QAAQ,UAAU,CAAC,OAAO;YACpC,CAAC;QAED,MAAM,mBAAmB,SAAS,MAAM;QACxC,MAAM,oBAAoB,qBAAqB;QAE/C,OAAO;YACL;YACA;YACA;YACA;YACA;YACA,UAAU;YACV,WAAW,IAAI,OAAO,WAAW;YACjC;QACF;IACF,EAAE,OAAO,OAAO;QACd,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAE9D,OAAO;YACL;YACA;YACA;YACA,kBAAkB,CAAC;YACnB,mBAAmB;YACnB,UAAU;YACV,WAAW,IAAI,OAAO,WAAW;YACjC,UAAU,EAAE;YACZ,OAAO;QACT;IACF;AACF;AAMO,SAAS,kBAAkB,MAAqB;IACrD,MAAM,OAAO,KAAK,SAAS,CAAC;QAC1B,QAAQ,OAAO,MAAM;QACrB,KAAK,OAAO,OAAO;QACnB,KAAK,OAAO,OAAO;QACnB,WAAW,OAAO,iBAAiB;QACnC,WAAW,OAAO,SAAS;QAC3B,eAAe,OAAO,gBAAgB;IACxC;IAEA,kEAAkE;IAClE,IAAI,OAAO;IACX,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;QACpC,MAAM,OAAO,KAAK,UAAU,CAAC;QAC7B,OAAO,AAAC,CAAC,QAAQ,CAAC,IAAI,OAAQ;QAC9B,OAAO,OAAO;IAChB;IAEA,OAAO,OAAO,KAAK,GAAG,CAAC,MAAM,QAAQ,CAAC,IAAI,QAAQ,CAAC,IAAI;AACzD"}},
    {"offset": {"line": 285, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/app/api/farms/%5Bid%5D/verify/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { MOCK_FARMS } from '@/lib/data/mockData';\nimport { checkFarmHotspots, generateProofHash } from '@/lib/gistda/hotspotChecker';\n\nexport async function POST(\n  request: Request,\n  context: { params: Promise<{ id: string }> }\n) {\n  const { id } = await context.params;\n  const farm = MOCK_FARMS.find(f => f.id === id);\n\n  if (!farm) {\n    return NextResponse.json({ error: 'Farm not found' }, { status: 404 });\n  }\n\n  try {\n    // Check for hotspots at farm location using GISTDA API\n    const result = await checkFarmHotspots(\n      farm.id,\n      farm.location.lat,\n      farm.location.lng,\n      1 // 1km buffer\n    );\n\n    // Generate proof hash (would be zkTLS proof in production)\n    const proofHash = generateProofHash(result);\n\n    return NextResponse.json({\n      success: true,\n      farmId: farm.id,\n      farmName: farm.name,\n      location: farm.location,\n      verification: {\n        hotspotsDetected: result.hotspotsDetected,\n        noBurningDetected: result.noBurningDetected,\n        eligible: result.eligible,\n        checkDate: result.checkDate,\n        proofHash,\n        hotspots: result.hotspots,\n      },\n      error: result.error,\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    return NextResponse.json(\n      { \n        success: false, \n        error: errorMessage,\n        farmId: farm.id,\n      },\n      { status: 500 }\n    );\n  }\n}\n\n// GET endpoint to check verification status\nexport async function GET(\n  request: Request,\n  context: { params: Promise<{ id: string }> }\n) {\n  const { id } = await context.params;\n  const farm = MOCK_FARMS.find(f => f.id === id);\n\n  if (!farm) {\n    return NextResponse.json({ error: 'Farm not found' }, { status: 404 });\n  }\n\n  // Return farm's current status and location for verification\n  return NextResponse.json({\n    farmId: farm.id,\n    farmName: farm.name,\n    location: farm.location,\n    currentStatus: {\n      hasBurning: farm.hasBurning,\n      burningIncidents: farm.burningIncidents,\n      insuranceStatus: farm.insuranceStatus,\n    },\n    gistdaApiUrl: buildGistdaUrl(farm.location.lat, farm.location.lng),\n  });\n}\n\nfunction buildGistdaUrl(lat: number, lng: number, buffer: number = 0.01): string {\n  const baseUrl = 'https://gistdaportal.gistda.or.th/data/rest/services/FR_Fire/hotspot_npp_daily/MapServer/0/query';\n  const params = new URLSearchParams({\n    where: \"lu_name='พื้นที่เกษตร'\",\n    geometry: `${lng - buffer},${lat - buffer},${lng + buffer},${lat + buffer}`,\n    geometryType: 'esriGeometryEnvelope',\n    spatialRel: 'esriSpatialRelIntersects',\n    outFields: '*',\n    f: 'json'\n  });\n  return `${baseUrl}?${params.toString()}`;\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAEO,eAAe,KACpB,OAAgB,EAChB,OAA4C;IAE5C,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,QAAQ,MAAM;IACnC,MAAM,OAAO,uIAAU,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;IAE3C,IAAI,CAAC,MAAM;QACT,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACtE;IAEA,IAAI;QACF,uDAAuD;QACvD,MAAM,SAAS,MAAM,IAAA,sJAAiB,EACpC,KAAK,EAAE,EACP,KAAK,QAAQ,CAAC,GAAG,EACjB,KAAK,QAAQ,CAAC,GAAG,EACjB,EAAE,aAAa;;QAGjB,2DAA2D;QAC3D,MAAM,YAAY,IAAA,sJAAiB,EAAC;QAEpC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,QAAQ,KAAK,EAAE;YACf,UAAU,KAAK,IAAI;YACnB,UAAU,KAAK,QAAQ;YACvB,cAAc;gBACZ,kBAAkB,OAAO,gBAAgB;gBACzC,mBAAmB,OAAO,iBAAiB;gBAC3C,UAAU,OAAO,QAAQ;gBACzB,WAAW,OAAO,SAAS;gBAC3B;gBACA,UAAU,OAAO,QAAQ;YAC3B;YACA,OAAO,OAAO,KAAK;QACrB;IACF,EAAE,OAAO,OAAO;QACd,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC9D,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO;YACP,QAAQ,KAAK,EAAE;QACjB,GACA;YAAE,QAAQ;QAAI;IAElB;AACF;AAGO,eAAe,IACpB,OAAgB,EAChB,OAA4C;IAE5C,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,QAAQ,MAAM;IACnC,MAAM,OAAO,uIAAU,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;IAE3C,IAAI,CAAC,MAAM;QACT,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACtE;IAEA,6DAA6D;IAC7D,OAAO,gJAAY,CAAC,IAAI,CAAC;QACvB,QAAQ,KAAK,EAAE;QACf,UAAU,KAAK,IAAI;QACnB,UAAU,KAAK,QAAQ;QACvB,eAAe;YACb,YAAY,KAAK,UAAU;YAC3B,kBAAkB,KAAK,gBAAgB;YACvC,iBAAiB,KAAK,eAAe;QACvC;QACA,cAAc,eAAe,KAAK,QAAQ,CAAC,GAAG,EAAE,KAAK,QAAQ,CAAC,GAAG;IACnE;AACF;AAEA,SAAS,eAAe,GAAW,EAAE,GAAW,EAAE,SAAiB,IAAI;IACrE,MAAM,UAAU;IAChB,MAAM,SAAS,IAAI,gBAAgB;QACjC,OAAO;QACP,UAAU,GAAG,MAAM,OAAO,CAAC,EAAE,MAAM,OAAO,CAAC,EAAE,MAAM,OAAO,CAAC,EAAE,MAAM,QAAQ;QAC3E,cAAc;QACd,YAAY;QACZ,WAAW;QACX,GAAG;IACL;IACA,OAAO,GAAG,QAAQ,CAAC,EAAE,OAAO,QAAQ,IAAI;AAC1C"}}]
}