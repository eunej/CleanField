{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/lib/data/mockData.ts"],"sourcesContent":["import { Farm, BurningRecord, InsurancePayment } from '@/lib/types/farm';\n\n// Mock farm data\nexport const MOCK_FARMS: Farm[] = [\n  {\n    id: 'farm1',\n    name: 'Green Valley Farm',\n    owner: 'สมชาย ใจดี',\n    walletAddress: '0x1234567890123456789012345678901234567890',\n    location: { lat: 13.7563, lng: 100.5018 },\n    area: 25.5,\n    registrationDate: '2024-01-15',\n    lastCheckDate: '2026-01-28',\n    hasBurning: false,\n    burningIncidents: 0,\n    insuranceStatus: 'active',\n    rewardAmount: 500,\n  },\n  {\n    id: 'farm2',\n    name: 'Sunrise Orchards',\n    owner: 'นิรันดร์ สุขสวัสดิ์',\n    walletAddress: '0x2345678901234567890123456789012345678901',\n    location: { lat: 14.3532, lng: 100.5698 },\n    area: 18.2,\n    registrationDate: '2024-02-20',\n    lastCheckDate: '2026-01-28',\n    hasBurning: true,\n    burningIncidents: 2,\n    insuranceStatus: 'ineligible',\n    rewardAmount: 0,\n  },\n  {\n    id: 'farm3',\n    name: 'Golden Harvest Fields',\n    owner: 'อภิญญา วงศ์สกุล',\n    walletAddress: '0x3456789012345678901234567890123456789012',\n    location: { lat: 15.8700, lng: 100.9925 },\n    area: 42.0,\n    registrationDate: '2024-03-10',\n    lastCheckDate: '2026-01-28',\n    hasBurning: false,\n    burningIncidents: 0,\n    insuranceStatus: 'paid',\n    rewardAmount: 800,\n  },\n  {\n    id: 'farm4',\n    name: 'River Bend Agriculture',\n    owner: 'กิตติศักดิ์ เจริญผล',\n    walletAddress: '0x4567890123456789012345678901234567890123',\n    location: { lat: 16.4419, lng: 102.8359 },\n    area: 33.7,\n    registrationDate: '2024-04-05',\n    lastCheckDate: '2026-01-28',\n    hasBurning: false,\n    burningIncidents: 0,\n    insuranceStatus: 'pending',\n    rewardAmount: 650,\n  },\n  {\n    id: 'farm5',\n    name: 'Mountain View Plantation',\n    owner: 'ปราณี ศรีสุข',\n    walletAddress: '0x5678901234567890123456789012345678901234',\n    location: { lat: 18.7883, lng: 98.9853 },\n    area: 51.3,\n    registrationDate: '2024-05-12',\n    lastCheckDate: '2026-01-28',\n    hasBurning: true,\n    burningIncidents: 1,\n    insuranceStatus: 'ineligible',\n    rewardAmount: 0,\n  },\n];\n\n// Mock burning records\nexport const MOCK_BURNING_RECORDS: BurningRecord[] = [\n  {\n    farmId: 'farm2',\n    date: '2026-01-10',\n    severity: 'medium',\n    verified: true,\n  },\n  {\n    farmId: 'farm2',\n    date: '2026-01-22',\n    severity: 'low',\n    verified: true,\n  },\n  {\n    farmId: 'farm5',\n    date: '2026-01-18',\n    severity: 'high',\n    verified: true,\n  },\n];\n\n// Mock insurance payments\nexport const MOCK_PAYMENTS: InsurancePayment[] = [\n  {\n    farmId: 'farm1',\n    amount: 500,\n    timestamp: '2026-01-28T10:00:00Z',\n    status: 'pending',\n  },\n  {\n    farmId: 'farm3',\n    amount: 800,\n    timestamp: '2026-01-27T15:30:00Z',\n    txHash: '0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890',\n    status: 'completed',\n  },\n  {\n    farmId: 'farm4',\n    amount: 650,\n    timestamp: '2026-01-28T09:15:00Z',\n    status: 'pending',\n  },\n];\n"],"names":[],"mappings":";;;;;;;;AAGO,MAAM,aAAqB;IAChC;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAS;QACxC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;IACA;QACE,IAAI;QACJ,MAAM;QACN,OAAO;QACP,eAAe;QACf,UAAU;YAAE,KAAK;YAAS,KAAK;QAAQ;QACvC,MAAM;QACN,kBAAkB;QAClB,eAAe;QACf,YAAY;QACZ,kBAAkB;QAClB,iBAAiB;QACjB,cAAc;IAChB;CACD;AAGM,MAAM,uBAAwC;IACnD;QACE,QAAQ;QACR,MAAM;QACN,UAAU;QACV,UAAU;IACZ;IACA;QACE,QAAQ;QACR,MAAM;QACN,UAAU;QACV,UAAU;IACZ;IACA;QACE,QAAQ;QACR,MAAM;QACN,UAAU;QACV,UAAU;IACZ;CACD;AAGM,MAAM,gBAAoC;IAC/C;QACE,QAAQ;QACR,QAAQ;QACR,WAAW;QACX,QAAQ;IACV;IACA;QACE,QAAQ;QACR,QAAQ;QACR,WAAW;QACX,QAAQ;QACR,QAAQ;IACV;IACA;QACE,QAAQ;QACR,QAAQ;QACR,WAAW;QACX,QAAQ;IACV;CACD"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/lib/zktls/types.ts"],"sourcesContent":["// Primus zkTLS Types for GISTDA Integration\n\nexport interface ZkTLSConfig {\n  appId: string;\n  appSecret: string;\n  templateId: string;\n  mode: 'proxytls' | 'mpctls';\n}\n\nexport interface AttestationRequest {\n  templateId: string;\n  userAddress: string;\n  mode: 'proxytls' | 'mpctls';\n  conditions?: AttestationCondition[][];\n}\n\nexport interface AttestationCondition {\n  field: string;\n  op: 'SHA256' | '>' | '<' | '=' | '!=' | '>=' | '<=';\n  value?: string;\n}\n\nexport interface AttestationResult {\n  success: boolean;\n  attestationId: string;\n  timestamp: number;\n  data: {\n    farmId: string;\n    gistdaId: string;\n    noBurningDetected: boolean;\n    hotspotsCount: number;\n    checkDate: string;\n    location: {\n      lat: number;\n      lng: number;\n    };\n  };\n  proof: {\n    hash: string;\n    signature: string;\n    attestorPublicKey: string;\n  };\n  rawResponse?: unknown;\n}\n\nexport interface VerificationResult {\n  verified: boolean;\n  attestation: AttestationResult | null;\n  error?: string;\n}\n\nexport interface GISTDAHotspotData {\n  totalHotspots: number;\n  hotspots: Array<{\n    latitude: number;\n    longitude: number;\n    acquisitionDate: string;\n    confidence: string;\n    brightness: number;\n    landUse: string;\n  }>;\n  queryArea: {\n    minLat: number;\n    maxLat: number;\n    minLng: number;\n    maxLng: number;\n  };\n  status: 'NO_BURNING' | 'BURNING_DETECTED' | 'ERROR';\n}\n\n// GISTDA API Response structure\nexport interface GISTDAApiResponse {\n  features?: Array<{\n    attributes: {\n      OBJECTID: number;\n      latitude: number;\n      longitude: number;\n      acq_date: string;\n      confidence: string;\n      brightness: number;\n      lu_name: string;\n    };\n    geometry?: {\n      x: number;\n      y: number;\n    };\n  }>;\n  error?: {\n    code: number;\n    message: string;\n  };\n}\n\n// Primus SDK Response Types (based on official SDK)\nexport interface PrimusAttestationResponse {\n  attestation: {\n    id: string;\n    timestamp: string;\n    data: Record<string, unknown>;\n    signature: string;\n    publicKey: string;\n  };\n  verified: boolean;\n}\n"],"names":[],"mappings":"AAAA,4CAA4C"}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/lib/zktls/primusClient.ts"],"sourcesContent":["/**\n * Primus zkTLS Client for GISTDA Verification\n * \n * This module provides zkTLS integration with Thailand's GISTDA portal\n * for verifying farm burning status using cryptographic proofs.\n * \n * @see https://docs.primuslabs.xyz/enterprise/zk-tls-sdk/overview\n */\n\nimport {\n  ZkTLSConfig,\n  AttestationResult,\n  VerificationResult,\n  GISTDAHotspotData,\n  GISTDAApiResponse,\n} from './types';\n\n// Environment configuration\nconst PRIMUS_CONFIG: ZkTLSConfig = {\n  appId: process.env.NEXT_PUBLIC_PRIMUS_APP_ID || 'demo_app_id',\n  appSecret: process.env.PRIMUS_APP_SECRET || 'demo_app_secret',\n  templateId: process.env.NEXT_PUBLIC_PRIMUS_TEMPLATE_ID || 'gistda_hotspot_template',\n  mode: 'proxytls', // Default to proxy mode for better performance\n};\n\n// GISTDA API Configuration\nconst GISTDA_CONFIG = {\n  baseUrl: 'https://gistdaportal.gistda.or.th/data/rest/services/FR_Fire/hotspot_npp_daily/MapServer/0/query',\n  agriculturalLandFilter: \"lu_name='พื้นที่เกษตร'\", // Filter for agricultural land\n  defaultBufferKm: 1, // 1km buffer around farm location\n};\n\n/**\n * Query GISTDA API for hotspots at a specific location\n */\nexport async function queryGISTDAHotspots(\n  lat: number,\n  lng: number,\n  bufferKm: number = GISTDA_CONFIG.defaultBufferKm\n): Promise<GISTDAHotspotData> {\n  // Convert km to approximate degrees (1 degree ≈ 111km at equator)\n  const buffer = bufferKm / 111;\n\n  const params = new URLSearchParams({\n    where: GISTDA_CONFIG.agriculturalLandFilter,\n    geometry: `${lng - buffer},${lat - buffer},${lng + buffer},${lat + buffer}`,\n    geometryType: 'esriGeometryEnvelope',\n    spatialRel: 'esriSpatialRelIntersects',\n    outFields: '*',\n    f: 'json',\n  });\n\n  const url = `${GISTDA_CONFIG.baseUrl}?${params.toString()}`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: { 'Accept': 'application/json' },\n      signal: AbortSignal.timeout(30000),\n    });\n\n    if (!response.ok) {\n      throw new Error(`GISTDA API error: ${response.status}`);\n    }\n\n    const data: GISTDAApiResponse = await response.json();\n\n    if (data.error) {\n      throw new Error(`GISTDA API error: ${data.error.message}`);\n    }\n\n    const hotspots = (data.features || []).map(f => ({\n      latitude: f.attributes.latitude || f.geometry?.y || 0,\n      longitude: f.attributes.longitude || f.geometry?.x || 0,\n      acquisitionDate: f.attributes.acq_date,\n      confidence: f.attributes.confidence,\n      brightness: f.attributes.brightness,\n      landUse: f.attributes.lu_name,\n    }));\n\n    return {\n      totalHotspots: hotspots.length,\n      hotspots,\n      queryArea: {\n        minLat: lat - buffer,\n        maxLat: lat + buffer,\n        minLng: lng - buffer,\n        maxLng: lng + buffer,\n      },\n      status: hotspots.length === 0 ? 'NO_BURNING' : 'BURNING_DETECTED',\n    };\n  } catch (error) {\n    console.error('GISTDA API query failed:', error);\n    return {\n      totalHotspots: -1,\n      hotspots: [],\n      queryArea: {\n        minLat: lat - buffer,\n        maxLat: lat + buffer,\n        minLng: lng - buffer,\n        maxLng: lng + buffer,\n      },\n      status: 'ERROR',\n    };\n  }\n}\n\n/**\n * Generate a cryptographic proof hash for the attestation\n * In production, this would be generated by the Primus zkTLS SDK\n */\nfunction generateProofHash(data: Record<string, unknown>): string {\n  const jsonStr = JSON.stringify(data);\n  let hash = 0;\n  for (let i = 0; i < jsonStr.length; i++) {\n    const char = jsonStr.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return '0x' + Math.abs(hash).toString(16).padStart(64, '0');\n}\n\n/**\n * Generate zkTLS attestation signature (simulated)\n * In production, this would be signed by Primus attestors\n */\nfunction generateAttestationSignature(proofHash: string, timestamp: number): string {\n  const data = `${proofHash}:${timestamp}:${PRIMUS_CONFIG.appId}`;\n  let sig = 0;\n  for (let i = 0; i < data.length; i++) {\n    sig = ((sig << 7) - sig) + data.charCodeAt(i);\n    sig = sig & sig;\n  }\n  return '0x' + Math.abs(sig).toString(16).padStart(128, '0');\n}\n\n/**\n * Create zkTLS attestation for GISTDA hotspot verification\n * \n * This function:\n * 1. Queries GISTDA API for hotspots at farm location\n * 2. Creates a cryptographic attestation of the result\n * 3. Returns proof that can be submitted on-chain\n * \n * @param farmId - Unique farm identifier\n * @param gistdaId - GISTDA portal farm ID\n * @param lat - Farm latitude\n * @param lng - Farm longitude\n * @param userAddress - User's wallet address\n */\nexport async function createGISTDAAttestation(\n  farmId: string,\n  gistdaId: string,\n  lat: number,\n  lng: number,\n  userAddress: string\n): Promise<AttestationResult> {\n  const timestamp = Date.now();\n  const checkDate = new Date(timestamp).toISOString();\n\n  // Step 1: Query GISTDA API for hotspot data\n  const gistdaData = await queryGISTDAHotspots(lat, lng);\n\n  // Step 2: Prepare attestation data\n  const attestationData = {\n    farmId,\n    gistdaId,\n    noBurningDetected: gistdaData.status === 'NO_BURNING',\n    hotspotsCount: gistdaData.totalHotspots,\n    checkDate,\n    location: { lat, lng },\n    queryArea: gistdaData.queryArea,\n    userAddress,\n    appId: PRIMUS_CONFIG.appId,\n    templateId: PRIMUS_CONFIG.templateId,\n    mode: PRIMUS_CONFIG.mode,\n  };\n\n  // Step 3: Generate cryptographic proof\n  const proofHash = generateProofHash(attestationData);\n  const signature = generateAttestationSignature(proofHash, timestamp);\n\n  // Step 4: Create attestation result\n  const attestation: AttestationResult = {\n    success: gistdaData.status !== 'ERROR',\n    attestationId: `att_${farmId}_${timestamp}`,\n    timestamp,\n    data: {\n      farmId,\n      gistdaId,\n      noBurningDetected: gistdaData.status === 'NO_BURNING',\n      hotspotsCount: gistdaData.totalHotspots,\n      checkDate,\n      location: { lat, lng },\n    },\n    proof: {\n      hash: proofHash,\n      signature,\n      attestorPublicKey: 'primus_attestor_pubkey_demo',\n    },\n    rawResponse: gistdaData,\n  };\n\n  return attestation;\n}\n\n/**\n * Verify a zkTLS attestation\n * \n * In production, this would verify:\n * 1. The signature is valid from a trusted Primus attestor\n * 2. The proof hash matches the attestation data\n * 3. The attestation is not expired\n */\nexport async function verifyAttestation(\n  attestation: AttestationResult\n): Promise<VerificationResult> {\n  try {\n    // Verify attestation is not too old (24 hours max)\n    const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n    const age = Date.now() - attestation.timestamp;\n    \n    if (age > maxAge) {\n      return {\n        verified: false,\n        attestation: null,\n        error: 'Attestation has expired (older than 24 hours)',\n      };\n    }\n\n    // Verify proof hash matches data\n    const expectedHash = generateProofHash({\n      farmId: attestation.data.farmId,\n      gistdaId: attestation.data.gistdaId,\n      noBurningDetected: attestation.data.noBurningDetected,\n      hotspotsCount: attestation.data.hotspotsCount,\n      checkDate: attestation.data.checkDate,\n      location: attestation.data.location,\n      queryArea: (attestation.rawResponse as GISTDAHotspotData)?.queryArea,\n      userAddress: '', // Not included in verification\n      appId: PRIMUS_CONFIG.appId,\n      templateId: PRIMUS_CONFIG.templateId,\n      mode: PRIMUS_CONFIG.mode,\n    });\n\n    // In production, verify signature with Primus attestor public key\n    // For demo, we just check the attestation was successful\n    if (!attestation.success) {\n      return {\n        verified: false,\n        attestation,\n        error: 'Attestation was not successful',\n      };\n    }\n\n    return {\n      verified: true,\n      attestation,\n    };\n  } catch (error) {\n    return {\n      verified: false,\n      attestation: null,\n      error: error instanceof Error ? error.message : 'Verification failed',\n    };\n  }\n}\n\n/**\n * Format attestation for on-chain submission\n * Returns data structured for smart contract interaction\n */\nexport function formatForOnChain(attestation: AttestationResult): {\n  farmId: string;\n  proofHash: string;\n  noBurningDetected: boolean;\n  timestamp: number;\n} {\n  return {\n    farmId: attestation.data.farmId,\n    proofHash: attestation.proof.hash,\n    noBurningDetected: attestation.data.noBurningDetected,\n    timestamp: attestation.timestamp,\n  };\n}\n\n/**\n * Get Primus configuration (without secrets)\n */\nexport function getPublicConfig(): Omit<ZkTLSConfig, 'appSecret'> {\n  return {\n    appId: PRIMUS_CONFIG.appId,\n    templateId: PRIMUS_CONFIG.templateId,\n    mode: PRIMUS_CONFIG.mode,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 427, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/lib/zktls/index.ts"],"sourcesContent":["/**\n * Primus zkTLS Integration for VeriFarm\n * \n * This module provides zkTLS-based verification of GISTDA hotspot data\n * for the Smog-Free Farmer Oracle project.\n * \n * @module zktls\n */\n\nexport * from './types';\nexport * from './primusClient';\n\n// Re-export main functions for convenience\nexport {\n  createGISTDAAttestation,\n  verifyAttestation,\n  queryGISTDAHotspots,\n  formatForOnChain,\n  getPublicConfig,\n} from './primusClient';\n"],"names":[],"mappings":";AAAA;;;;;;;CAOC,GAED;AACA"}},
    {"offset": {"line": 444, "column": 0}, "map": {"version":3,"sources":["file:///Users/ej/Hackathon/VeriFarm/app/api/zktls/attest/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { MOCK_FARMS } from '@/lib/data/mockData';\nimport {\n  createGISTDAAttestation,\n  verifyAttestation,\n  formatForOnChain,\n  getPublicConfig,\n} from '@/lib/zktls';\n\n/**\n * POST /api/zktls/attest\n * \n * Create a zkTLS attestation for farm burning status verification\n * \n * Request body:\n * - farmId: string - Farm identifier\n * - userAddress: string - User's wallet address (optional)\n * \n * Response:\n * - attestation: Full attestation result\n * - verification: Verification status\n * - onChainData: Data formatted for smart contract submission\n */\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const { farmId, userAddress = '0x0000000000000000000000000000000000000000' } = body;\n\n    // Find farm in mock data\n    const farm = MOCK_FARMS.find(f => f.id === farmId);\n    if (!farm) {\n      return NextResponse.json(\n        { success: false, error: 'Farm not found' },\n        { status: 404 }\n      );\n    }\n\n    // Check if farm has burning detected (ineligible for zkTLS proof)\n    if (farm.hasBurning) {\n      return NextResponse.json({\n        success: false,\n        farmId: farm.id,\n        farmName: farm.name,\n        owner: farm.owner,\n        attestation: null,\n        verification: {\n          verified: false,\n          error: 'Farm has burning incidents detected - ineligible for clean air proof',\n        },\n        onChainData: null,\n        config: getPublicConfig(),\n        reason: 'BURNING_DETECTED',\n        burningIncidents: farm.burningIncidents,\n      });\n    }\n\n    // Create zkTLS attestation\n    const attestation = await createGISTDAAttestation(\n      farm.id,\n      `GISTDA_${farm.id}`, // Mock GISTDA ID\n      farm.location.lat,\n      farm.location.lng,\n      userAddress\n    );\n\n    // Verify the attestation\n    const verification = await verifyAttestation(attestation);\n\n    // Format for on-chain submission\n    const onChainData = formatForOnChain(attestation);\n\n    return NextResponse.json({\n      success: attestation.success,\n      farmId: farm.id,\n      farmName: farm.name,\n      owner: farm.owner,\n      attestation: {\n        id: attestation.attestationId,\n        timestamp: attestation.timestamp,\n        data: attestation.data,\n        proof: attestation.proof,\n      },\n      verification: {\n        verified: verification.verified,\n        error: verification.error,\n      },\n      onChainData,\n      config: getPublicConfig(),\n    });\n  } catch (error) {\n    console.error('zkTLS attestation error:', error);\n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : 'Attestation failed',\n      },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * GET /api/zktls/attest\n * \n * Get zkTLS configuration info\n */\nexport async function GET() {\n  return NextResponse.json({\n    name: 'Primus zkTLS GISTDA Attestation Service',\n    version: '1.0.0',\n    config: getPublicConfig(),\n    endpoints: {\n      attest: 'POST /api/zktls/attest',\n      verify: 'POST /api/zktls/verify',\n      batchAttest: 'POST /api/zktls/batch-attest',\n    },\n    documentation: '/docs/zkTLS_INTEGRATION.md',\n  });\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AAAA;;;;AAqBO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,MAAM,EAAE,cAAc,4CAA4C,EAAE,GAAG;QAE/E,yBAAyB;QACzB,MAAM,OAAO,uIAAU,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAC3C,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAiB,GAC1C;gBAAE,QAAQ;YAAI;QAElB;QAEA,kEAAkE;QAClE,IAAI,KAAK,UAAU,EAAE;YACnB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,QAAQ,KAAK,EAAE;gBACf,UAAU,KAAK,IAAI;gBACnB,OAAO,KAAK,KAAK;gBACjB,aAAa;gBACb,cAAc;oBACZ,UAAU;oBACV,OAAO;gBACT;gBACA,aAAa;gBACb,QAAQ,IAAA,iJAAe;gBACvB,QAAQ;gBACR,kBAAkB,KAAK,gBAAgB;YACzC;QACF;QAEA,2BAA2B;QAC3B,MAAM,cAAc,MAAM,IAAA,yJAAuB,EAC/C,KAAK,EAAE,EACP,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE,EACnB,KAAK,QAAQ,CAAC,GAAG,EACjB,KAAK,QAAQ,CAAC,GAAG,EACjB;QAGF,yBAAyB;QACzB,MAAM,eAAe,MAAM,IAAA,mJAAiB,EAAC;QAE7C,iCAAiC;QACjC,MAAM,cAAc,IAAA,kJAAgB,EAAC;QAErC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS,YAAY,OAAO;YAC5B,QAAQ,KAAK,EAAE;YACf,UAAU,KAAK,IAAI;YACnB,OAAO,KAAK,KAAK;YACjB,aAAa;gBACX,IAAI,YAAY,aAAa;gBAC7B,WAAW,YAAY,SAAS;gBAChC,MAAM,YAAY,IAAI;gBACtB,OAAO,YAAY,KAAK;YAC1B;YACA,cAAc;gBACZ,UAAU,aAAa,QAAQ;gBAC/B,OAAO,aAAa,KAAK;YAC3B;YACA;YACA,QAAQ,IAAA,iJAAe;QACzB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD,GACA;YAAE,QAAQ;QAAI;IAElB;AACF;AAOO,eAAe;IACpB,OAAO,gJAAY,CAAC,IAAI,CAAC;QACvB,MAAM;QACN,SAAS;QACT,QAAQ,IAAA,iJAAe;QACvB,WAAW;YACT,QAAQ;YACR,QAAQ;YACR,aAAa;QACf;QACA,eAAe;IACjB;AACF"}}]
}